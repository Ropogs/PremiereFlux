<#
    Multi-Option Video Converter for Premiere Pro 

    DESCRIPTION:
      This script is designed to help you convert and reformat video files to be compatible with Premiere Pro. It offers a variety of functionalities for processing multiple video files and adjusting settings for both video and audio streams. The script supports automatic re-encoding and remuxing, as well as custom audio handling and batch file processing.

    KEY FEATURES:

      • **Efficient Metadata Handling**: 
        - The script makes only **one call to `ffprobe` per file** to extract metadata. This metadata is passed around to avoid redundant `ffprobe` calls, optimizing the processing time for each file.
        
      • **Video Editing-Friendly Check**:
        - It checks if the video is already in an editing-friendly format (e.g., ProRes, DNxHR, H.264). The check is done using the metadata extracted from `ffprobe`. If the video is in a compatible format, the script can either **copy** the video stream (without re-encoding) or **re-encode** it based on the user's choice.

      • **Audio Stream Handling**:
        - **Downmixing**: Option to **downmix multi-channel audio** (e.g., 5.1, 7.1) to stereo (2 channels) if desired. If the audio is already stereo, no downmixing will occur.
        - Handles **non-PCM audio formats** (e.g., AAC, DTS) and converts them to **uncompressed PCM (16-bit, 48 kHz)**.
        - **Audio Renaming**: After encoding, the audio track names are modified to include the **language code**, **codec** (e.g., PCM), and **channel configuration** (e.g., stereo, mono, 5.1).

      • **Batch Output Naming**:
        - The user is prompted to select a **batch output filename template** via a `SaveFileDialog`.
        - For each input file, a unique name is generated by appending a sequential number (e.g., `acatmovie_1.mp4`, `acatmovie_2.mp4`).
        - This ensures that output files don't overwrite each other when processing multiple files.

      • **Video Codec Options**:
        - The user can choose from the following video encoding options:
            1. **H.264 (NVENC)**: GPU-accelerated encoding for fast processing (requires an NVIDIA GPU with NVENC support, will fall back to CPU if CUDA is unavailable).
            2. **H.264 (CPU)**: Software-based encoding for general compatibility.
            3. **ProRes (CPU)**: High-quality, editing-friendly codec (large file sizes).
            4. **DNxHR (CPU)**: Another editing-friendly codec, with various quality options (also CPU-based, slower).

      • **Progressive Video Check and Deinterlacing**:
        - The script checks if the video is **progressive** or **interlaced**. If the video is interlaced, it applies the **yadif deinterlacing filter** to ensure smooth playback in Premiere Pro.

      • **Remuxing Support**:
        - If the video file is already in a compatible container (e.g., `.mp4` for H.264), but needs a different audio codec or container format, the script can **remux** the video without re-encoding the video stream.

      • **Error Handling**:
        - The script provides **error handling for both `ffprobe` and `ffmpeg`**. If a file is corrupt or the necessary tools are missing, it logs the error and continues with the remaining files.
        - Each `ffmpeg` command is **logged** in a file called `BatchConvertLog.txt` for reference. This log includes the exact command run for each file, which can be useful for debugging or re-running processes.

    WORKFLOW:
      1. **User Input**:
         - Choose how to handle already editing-friendly video (always re-encode, always copy, or ask per file).
         - Choose whether to downmix multi-channel audio to stereo.
         - Select the video encoding format from a 4-option menu (H.264 NVENC, H.264 CPU, ProRes, or DNxHR).
      2. **File Selection**:
         - Use a `OpenFileDialog` to select one or more files to process.
      3. **Output Filename Template**:
         - Use a `SaveFileDialog` to choose a template for output filenames. For example, if the template is `C:\Output\acatmovie.mp4` and you select 3 files, the outputs will be `C:\Output\acatmovie_1.mp4`, `C:\Output\acatmovie_2.mp4`, and so on.
      4. **Processing**:
         - For each file, the script processes the video and audio streams based on the user-defined settings (encoding, downmix, etc.), renames audio tracks, and ensures the final output is compatible with Premiere Pro.
      5. **Log File**:
         - After all files are processed, a log file (`BatchConvertLog.txt`) is created containing all the `ffmpeg` commands executed. This log is saved in the same directory as the script.
      6. **Completion**:
         - Once processing is complete, the script outputs a message indicating the number of processed files and the location of the log file.

    REQUIREMENTS:
      • **ffmpeg** and **ffprobe** must be installed and in your PATH for the script to work.
      • **For H.264 NVENC encoding**, an NVIDIA GPU with NVENC support is required (falls back to CPU if CUDA is unavailable).
      • Windows environment with PowerShell for script execution.

#>
Add-Type -AssemblyName System.Windows.Forms

# ---------------- HELPER FUNCTIONS ----------------

function Show-Menu {
    Write-Host "---------------------------------------"
    Write-Host " Choose your output codec:"
    Write-Host "   1) H.264 (NVENC) - GPU accelerated (if available)"
    Write-Host "   2) H.264 (CPU)   - fallback if no GPU"
    Write-Host "   3) ProRes (CPU)  - editing-friendly, large files"
    Write-Host "   4) DNxHR (CPU)   - editing-friendly, large files"
    Write-Host "---------------------------------------"
    $choice = Read-Host "Enter an option number (1-4)"
    return $choice
}

function Is-EditingFriendlyCodec {
    param (
        [Object]$parsedJson  # The JSON structure from ffprobe, already parsed
    )
    $videoStream = $parsedJson.streams | Where-Object { $_.codec_type -eq "video" } | Select-Object -First 1
    if (-not $videoStream) { return $false }

    $codec = $videoStream.codec_name
    if ($codec -eq "prores" -or $codec -match "dnx" -or $codec -match "cfhd" -or $codec -eq "h264") {
        return $true
    }
    return $false
}

function Get-FrameRate {
    param (
        [Object]$parsedJson  # We'll read avg_frame_rate from the first video stream
    )
    $videoStream = $parsedJson.streams | Where-Object { $_.codec_type -eq "video" } | Select-Object -First 1
    if (-not $videoStream) { return 30 }  # fallback

    $rawRate = $videoStream.avg_frame_rate
    if (-not $rawRate) { return 30 }

    if ($rawRate -match "/") {
        $parts = $rawRate -split '/'
        if ($parts.Length -eq 2 -and [int]$parts[1] -ne 0) {
            return [math]::Round([double]$parts[0] / [double]$parts[1], 3)
        }
    }
    elseif ($rawRate -ne "") {
        return $rawRate
    }
    return 30
}

function Is-AudioCompliant {
    param (
        [object]$audioStream
    )
    # Check if PCM 16-bit @ 48 kHz
    if ($audioStream.codec_name -eq "pcm_s16le" -and ([int]$audioStream.sample_rate) -eq 48000) {
        return $true
    }
    return $false
}

function Is-VideoCompliant {
    param (
        [object]$videoStream,
        [string]$finalPixFmt,
        [string]$desiredCodec
    )
    $compliant = $true

    if ($videoStream.width -ne 1920 -or $videoStream.height -ne 1080) { $compliant = $false }
    if ($videoStream.field_order -and $videoStream.field_order -notmatch "progressive") {
        $compliant = $false
    }
    if ($videoStream.pix_fmt -ne $finalPixFmt) { $compliant = $false }
    if ($videoStream.codec_name -ne $desiredCodec) { $compliant = $false }

    return $compliant
}

function Get-AudioChannelDescription {
    param (
        [int]$channels,
        [bool]$downmix
    )
    if ($downmix -and $channels -gt 2) {
        return "stereo"
    } else {
        switch ($channels) {
            { $_ -eq 1 } { return "mono" }
            { $_ -eq 2 } { return "stereo" }
            { $_ -eq 6 } { return "5.1" }
            { $_ -eq 8 } { return "7.1" }
            default       { return "$channels channels" }
        }
    }
}

function Check-HardwareAcceleration {
    # Check if CUDA hardware acceleration is available
    try {
        $gpuSupported = &ffmpeg -hwaccels 2>&1 | Select-String "cuda"
        return $gpuSupported -ne $null
    }
    catch {
        Write-Host "Error checking for hardware acceleration: $($_.Exception.Message)"
        return $false
    }
}

# ---------------- GLOBAL PROMPTS / OPTIONS ----------------

Write-Host "When a file's video stream is already editing-friendly (e.g. H.264, ProRes, DNxHR, CineForm):"
Write-Host "  1 = Always re-encode the video stream."
Write-Host "  2 = Always copy the video stream (do not re-encode)."
Write-Host "  3 = Ask per file."
$globalDecision = Read-Host "Enter your choice (1, 2, or 3) [default: 3]"
if ($globalDecision -eq "") { $globalDecision = "3" }

$downmixAudio = Read-Host "Downmix multi-channel audio (>2 channels) to stereo? (y/n) [default: n]"
if ($downmixAudio -eq "") { $downmixAudio = "n" }

# Show the main codec menu
$choice = Show-Menu

$hardwareAccelerationAvailable = Check-HardwareAcceleration

switch ($choice) {
    1 {
        Write-Host "You chose H.264 (NVENC)."
        if ($hardwareAccelerationAvailable) {
            Write-Host "Hardware acceleration (CUDA) available, using H.264 NVENC."
            $videoCodec = "h264_nvenc"
            $extraVideoArgs = @("-preset", "p4")
            $outputExtension = ".mp4"
            $infoMessage = "H.264 NVENC"
            $targetPixFmt = "yuv420p"
            $desiredCodec = "h264"
        } else {
            Write-Host "CUDA not available, falling back to H.264 CPU encoding."
            $videoCodec = "libx264"
            $extraVideoArgs = @("-preset", "slow")
            $outputExtension = ".mp4"
            $infoMessage = "H.264 (CPU)"
            $targetPixFmt = "yuv420p"
            $desiredCodec = "h264"
        }
    }
    2 {
        Write-Host "You chose H.264 (CPU)."
        $videoCodec = "libx264"
        $extraVideoArgs = @("-preset", "slow")
        $outputExtension = ".mp4"
        $infoMessage = "H.264 (CPU)"
        $targetPixFmt = "yuv420p"
        $desiredCodec = "h264"
    }
    3 {
        Write-Host "You chose ProRes (CPU)."
        $videoCodec = "prores_ks"
        $extraVideoArgs = @("-profile:v", "3")  # HQ
        $outputExtension = ".mov"
        $infoMessage = "ProRes"
        $targetPixFmt = "yuv422p"
        $desiredCodec = "prores"
    }
    4 {
        Write-Host "You chose DNxHR (CPU)."
        $videoCodec = "dnxhd"
        $extraVideoArgs = @("-profile:v", "dnxhr_hq")
        $outputExtension = ".mov"
        $infoMessage = "DNxHR"
        $targetPixFmt = "yuv422p"
        $desiredCodec = "dnxhd"
    }
    default {
        Write-Host "Invalid choice. Defaulting to H.264 NVENC."
        $videoCodec = "h264_nvenc"
        $extraVideoArgs = @()
        $outputExtension = ".mp4"
        $infoMessage = "H.264 NVENC"
        $targetPixFmt = "yuv420p"
        $desiredCodec = "h264"
    }
}

# Prompt the user for multiple input files
$OpenFileDialog = New-Object System.Windows.Forms.OpenFileDialog
$OpenFileDialog.InitialDirectory = (Get-Location).Path
$OpenFileDialog.Filter = "Video Files|*.mov;*.mp4;*.mkv;*.avi;*.wmv;*.flv;*.webm;*.mpeg;*.mpg;*.3gp;*.mts;*.m2ts;*.vob;*.divx;*.ogv;*.rmvb;*.m4v|All Files|*.*"
$OpenFileDialog.Multiselect = $true
$OpenFileDialog.Title = "Select Video Files to Process"

$saveDialog = New-Object System.Windows.Forms.SaveFileDialog
$saveDialog.Filter = "Output Template|*"  # we only want a filename, not a specific extension
$saveDialog.Title = "Select a Batch Output Filename Template"

# We'll store the ffmpeg commands in a list, then write them to a log at the end
$FfmpegCommandsLog = New-Object System.Collections.Generic.List[String]

# Ensure the log file exists
$scriptDir = Split-Path $MyInvocation.MyCommand.Path
$logFilePath = Join-Path $scriptDir "BatchConvertLog.txt"
if (-not (Test-Path $logFilePath)) {
    # Create the log file if it doesn't exist
    New-Item -ItemType File -Path $logFilePath -Force
}

# Function to log messages with timestamp and formatting
function Log-Message {
    param (
        [string]$message
    )
    $timestamp = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
    $logEntry = "[$timestamp] - $message"
    Write-Host $logEntry
    $logEntry | Out-File -FilePath $logFilePath -Append -Encoding UTF8
}

# Actually select the input files
if ($OpenFileDialog.ShowDialog() -eq [System.Windows.Forms.DialogResult]::OK) {
    $InputFiles = $OpenFileDialog.FileNames
} else {
    Log-Message "No input files selected. Exiting."
    return
}

# Prompt for output template
if ($saveDialog.ShowDialog() -eq [System.Windows.Forms.DialogResult]::OK) {
    $TemplatePath = $saveDialog.FileName
} else {
    Log-Message "No output filename template chosen. Exiting."
    return
}

# Main loop
$counter = 1
foreach ($File in $InputFiles) {
    Log-Message "--------------------------------------------"
    Log-Message "Processing file: $File"

    # We run ffprobe once, parse it, pass to our functions
    try {
        $ffprobeJson = & ffprobe -v quiet -print_format json -show_streams -show_format "$File"
    }
    catch {
        Log-Message "Error running ffprobe on '$File': $($_.Exception.Message). Skipping..."
        continue
    }
    if (-not $ffprobeJson) {
        Log-Message "No data from ffprobe on '$File'. Skipping..."
        continue
    }
    try {
        $parsed = $ffprobeJson | ConvertFrom-Json
    }
    catch {
        Log-Message "Error parsing ffprobe JSON for '$File': $($_.Exception.Message). Skipping..."
        continue
    }

    $videoStream = $parsed.streams | Where-Object { $_.codec_type -eq "video" } | Select-Object -First 1
    if (-not $videoStream) {
        Log-Message "No video stream found in '$File'. Skipping..."
        continue
    }
    $audioStreams = $parsed.streams | Where-Object { $_.codec_type -eq "audio" }

    # Container check
    $sourceExt = [System.IO.Path]::GetExtension($File).ToLower()
    $containerCompliant = ($sourceExt -eq [System.IO.Path]::GetExtension($TemplatePath).ToLower())
    if (-not $containerCompliant) {
        Log-Message "Source container ($sourceExt) differs from template container; we will remux."
    }

    # Check if editing-friendly
    $isEditingFriendly = Is-EditingFriendlyCodec -parsedJson $parsed
    $videoReencode = $true
    if ($isEditingFriendly) {
        switch ($globalDecision) {
            "1" { $videoReencode = $true }
            "2" { $videoReencode = $false }
            "3" {
                $ans = Read-Host "Video is editing-friendly. Re-encode it? (y/n) [default=n]"
                if ($ans.ToLower() -eq "y") {
                    $videoReencode = $true
                } else {
                    $videoReencode = $false
                }
            }
            default { $videoReencode = $false }
        }
    }

    # Get frame rate from the JSON
    $fps = Get-FrameRate -parsedJson $parsed
    Log-Message "Detected frame rate: $fps fps"

    # Deinterlace check
    $needsYadif = $true
    if ($videoStream.field_order -and $videoStream.field_order -match "progressive") {
        $needsYadif = $false
    }
    $deintFilter = ""
    if ($needsYadif) {
        Log-Message "Interlaced video detected, applying yadif."
        $deintFilter = "yadif,"
    }

    # Video arguments
    $videoArgs = @()
    if (-not $videoReencode) {
        Log-Message "Skipping re-encode for video (copy)."
        $videoArgs = @("-c:v", "copy")
    } else {
        if (Is-VideoCompliant -videoStream $videoStream -finalPixFmt $targetPixFmt -desiredCodec $desiredCodec) {
            Log-Message "Video is already compliant. Using copy."
            $videoArgs = @("-c:v", "copy")
        } else {
            Log-Message "Video not compliant -> re-encode with scale/pad."
            $FilterChain = "$deintFilter" + 
                "scale='if(gt(a,16/9),1920,-2)':'if(gt(a,16/9),-2,1080)'," + 
                "pad=1920:1080:(1920-iw)/2:(1080-ih)/2,format=$targetPixFmt"
            $videoArgs = @("-vf", "$FilterChain", "-c:v", $videoCodec) + $extraVideoArgs
        }
    }

    # Audio processing
    $audioMap = @()   # which audio indices we keep
    $audioArgs = @()
    for ($i = 0; $i -lt $audioStreams.Count; $i++) {
        $aStream = $audioStreams[$i]

        # Keep track of the audio index
        $audioMap += $i
        $currentChannels = [int]($aStream.channels | ForEach-Object { $_ })  # safe parse
        $willDownmix = ($downmixAudio -eq "y" -and $currentChannels -gt 2)

        if (Is-AudioCompliant -audioStream $aStream) {
            # Audio is already PCM, just copy it
            Log-Message "Audio track $i is already PCM@48kHz, 2ch or less. Copying."
            $audioArgs += @("-c:a:$i", "copy")
        } else {
            # Audio is not PCM, re-encode it to PCM 48kHz
            Log-Message "Audio track $i re-encoding -> PCM 48kHz."
            $audioArgs += @("-c:a:$i", "pcm_s16le", "-ar:a:$i", "48000")
            if ($willDownmix) {
                Log-Message "Downmixing audio track $i to stereo."
                $audioArgs += @("-ac:a:$i", "2")
            }
        }

        # Set metadata for the audio track (keep the default "und" language)
        $newTitle = "audio codec(pcm) channel number($(Get-AudioChannelDescription -channels $currentChannels -downmix $willDownmix))"
        Log-Message "Audio track $i new title: $newTitle"
        $audioArgs += @("-metadata:s:a:$i", "title=$newTitle")
    }

    # Construct final output path using the template
    $templateWithoutExt = [System.IO.Path]::GetFileNameWithoutExtension($TemplatePath)

    # Set the appropriate output extension based on the selected codec
    switch ($choice) {
        1 { $outputExtension = ".mp4" }  # H.264 NVENC/CPU
        2 { $outputExtension = ".mp4" }  # H.264 CPU
        3 { $outputExtension = ".mov" }  # ProRes
        4 { $outputExtension = ".mov" }  # DNxHR
        default { $outputExtension = ".mp4" }  # Default to H.264 MP4
    }

    # Ensure the filename doesn't have an extension already, then append the correct one
    $templateDir = [System.IO.Path]::GetDirectoryName($TemplatePath)
    $outputBase = Join-Path $templateDir ($templateWithoutExt + "_$counter" + $outputExtension)

    $counter++

    Log-Message "Final output path: $outputBase"

    # Build ffmpeg arguments
    $ffmpegArgs = @(
        "-hwaccel", "cuda",
        "-i", "$File"
    ) + $videoArgs + @(
        "-map", "0:v:0"
    )

    foreach ($aIdx in $audioMap) {
        $ffmpegArgs += @("-map", "0:a:$aIdx")
    }

    $ffmpegArgs += $audioArgs + @(
        "-r", "$fps",
        "-fps_mode", "cfr",
        "-movflags", "+faststart",
        "$outputBase"
    )

    # Log the ffmpeg command
    $cmdLine = "ffmpeg " + ($ffmpegArgs -join " ")
    $FfmpegCommandsLog.Add($cmdLine)

    Log-Message "Starting conversion for '$File' => '$outputBase'"
    Log-Message "FFmpeg command: $cmdLine"

    try {
        & ffmpeg @ffmpegArgs
    }
    catch {
        Log-Message "Error running ffmpeg: $($_.Exception.Message). Skipping."
        continue
    }

    Log-Message "Finished converting '$File'."
}

# After the loop, write the log
Log-Message "All processing completed."